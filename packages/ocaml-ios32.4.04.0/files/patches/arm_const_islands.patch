From 11d6c1d80b5cee903e5919ec8a67279fba608b52 Mon Sep 17 00:00:00 2001
From: whitequark <whitequark@whitequark.org>
Date: Fri, 30 Dec 2016 13:24:37 +0000
Subject: [PATCH] ARM: fix excessive immediate values for pc-relative ldr.

ARM does not have an instruction with a 32-bit immediate. Therefore,
on ARM, to load arbitrary 32-bit constants, there are two main
strategies: load the halves of the constant one by one (in Thumb,
this would be done with movw/movt), or periodically emit
the so-called constant islands, that is, small chunks of data inside
executable code that are jumped around.

Note that when loading constant islands, care must be taken to avoid
the same problem as what they are solving: the ldr instruction only
has a 12-bit offset, and so there may not be more than 4K of code
between the load and the constant island it refers to.

The OCaml ARM backend opts for the constant islands. It implements
it as follows: after emitting an instruction, it checks whether,
if the first instruction it has emitted since emitting a previous
constant island, can still address the last constant it is going
to emit.

This works in most cases, but not when emitting Lswitch. Consider
that a switch can have an arbitrarily large jump table. If the jump
table is larger than 4K, then, by the time we have emitted it,
all ldr instructions prior to the switch are irreparably broken.

This commit changes the constant island emission logic to first
calculate the size of an Lswitch, then consider emitting a constant
island, and only afterwards emitting Lswitch. For all other
instructions the logic is unchanged.

To do this in a fully rigorous way, arguably it would be better to
have a separate function that returns the size of an instruction,
and a separate one that emits an instruction. However, emit_instr
has quite a bit of logic, which can affect the size of
the instruction, and so I have opted against duplicating that logic,
on the grounds that this will make maintenance much trickier.
---
 asmcomp/arm/emit.mlp | 21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/asmcomp/arm/emit.mlp b/asmcomp/arm/emit.mlp
index de61da57d..0f4d19e83 100644
--- a/asmcomp/arm/emit.mlp
+++ b/asmcomp/arm/emit.mlp
@@ -802,9 +802,22 @@ let emit_instr i =
 
 (* Emission of an instruction sequence *)
 
+(* consider the degenerate case where a single literal is followed by
+   a jump table longer than 4KB; we have to emit the constant island
+   before the jump table or it will be too late *)
+let emit_instr_before_pool i =
+  match i.desc with
+  | Lswitch jumptbl -> 2 + Array.length jumptbl
+  | _ -> emit_instr i
+
+let emit_instr_after_pool i =
+  match i.desc with
+  | Lswitch _ -> ignore (emit_instr i); ()
+  | _ -> ()
+
 let rec emit_all ninstr i =
   if i.desc = Lend then () else begin
-    let n = emit_instr i in
+    let n = emit_instr_before_pool i in
     let ninstr' = ninstr + n in
     (* fldd can address up to +/-1KB, ldr can address up to +/-4KB *)
     let limit = (if !fpu >= VFPv2 && !float_literals <> []
@@ -813,15 +826,19 @@ let rec emit_all ninstr i =
     let limit = limit - !num_literals in
     if ninstr' >= limit - 64 && not(has_fallthrough i.desc) then begin
       emit_literals();
+      emit_instr_after_pool i;
       emit_all 0 i.next
     end else if !num_literals != 0 && ninstr' >= limit then begin
       let lbl = new_label() in
       `	b	{emit_label lbl}\n`;
       emit_literals();
       `{emit_label lbl}:\n`;
+      emit_instr_after_pool i;
       emit_all 0 i.next
-    end else
+    end else begin
+      emit_instr_after_pool i;
       emit_all ninstr' i.next
+    end
   end
 
 (* Emission of the profiling prelude *)
-- 
2.11.0

